\section{Related Work}
%- multichannel enables communication between more than one node to occur simultaneously and in a collision free manner

%\subsection{Existing Multichannel Protocol}
Radio duty cycling mechanism can be classified into two categories; synchronous and asynchronous system. A synchronous system is a system that requires a tight synchronisation between the nodes. It uses a tight time-scheduled communication where the network clock needs to be periodically synchronise in order for the nodes not to drift in time. Asynchronous multichannel on the other hand, does not require synchronisation but instead, is a sender or receiver initiated communications. It requires simple set up and the nodes are able to self-configure without tight synchronisation which is more appealing. There are many studies done in multichannel for both categories. Multichannel synchronous protocols for such as MC-LMAC \cite{mc-lmac} which uses time slot to transmit on a particular channel and Y-MAC \cite{y-mac}, EM-MAC \cite{emmac} and TSCH that depend on the neighbouring nodes to synchronise with each other. Multichannel asynchronous protocols such as MuChMAC \cite{muchmac}, Chrysso \cite{chrysso}, MiCMAC \cite{micmac} and our protocol are independent of time slot and synchronisation. 

%//!!why asynchronous vs synchronous important?
%This is important as in synchronous multichannel, the nodes need to be globally synchronise which is hard to achieve with frequent channel changes as the nodes need to maintain a tight synchronisation and need to synchronise the network clock periodically not to drift in time. Need to have a time-scheduled communication. Asynchronous multichannel on the other hand, can be either sender or receiver initiated communications. This shifts the global synchronise to local and does not affect the whole network.-simple setup, self-configurable as it does not need tight synchronisation.

ContikiMAC \cite{contikimac} is the default radio duty cycling protocol in Contiki that is responsible for the node wake-ups period. ContikiMAC is a power-saving radio duty cycling protocol. It was proved to be efficient in a single channel \cite{micmac}\cite{orpl}. ContikiMAC uses periodical wake-ups to listen to the neighbours transmission packet. It has a phase-lock mechanism to learn the neighbours wake-up phase to enable efficient transmissions and a fast sleep optimisation in case of spurious radio interference is detected. The sender uses the knowledge of the wake-up phase of the receiver to optimise its transmission. When a packet is successfully received, the receiver sends a link layer acknowledgement. The sender repeatedly sends its packet until it receives a link layer acknowledgement from the receiver. ContikiMAC relies on retransmissions for reliable transmissions. A Carrier Sense Multiple Access, CSMA is a MAC protocol that performs retransmissions when the underlying MAC layer has problems with collisions. When the sender does not receive the link layer acknowledgement, CSMA will retransmit the packets three times before dropping it from the buffer queue.
%CSMA is the MAC layer that takes care of retransmission of lost packets. 
%A packet is consider as loss when the sender does not receive the link layer acknowledgement. 


%//loss and retransmission - how it deals with it

%//be clear about when protocol suffers a loss

MiCMAC \cite{micmac} is a ContikiMAC \cite{contikimac} channel hopping variant. On every wakeup cycle, the channel is periodically switched according to a pseudo-random sequence. MiCMAC introduces channel lock for the channel reception at the sender. There is a dedicated broadcast channel for a duration at every wake up period. %MiCMAC can be used with RPL without any changes to RPL. %However, RPL might not formed properly because the nodes need to be on the broadcast channel at different time for different node according to the trickle timer to receive RPL control messages which are sent through unicast and broadcast.

Chrysso \cite{chrysso} is a multichannel protocol for data collection applications. The nodes are organised into parent-children groups where each parent-children uses two channels for transmitting and receiving packets. Our work also uses two separate channels as in Chrysso. Both parent and children nodes can hop to another channel when interference is detected based on the channel switching policies. If a node loses connectivity, Chrysso calls the scan mode to enable neighbour discovery over multiple channel. Chryssoâ€™s functionality comprises a set of channel switching policies that interface to both the MAC layer and the network layer.

However, MiCMAC and Chrysso are fully distributed which allow the nodes to self configure and change to another channel when interference happen. The channels that the protocols can used are fixed to several channel that were decided beforehand. Our protocol is centralised where most of the processes in channel assignment decisions are done by the LPBR. LPBR, which is the central point, is fully powered and does not have limited memory. We are able to produce real time channel selection decisions where we can consider all available channels to be used in transmissions without blacklisting any of them.  

%MiCMAC can be used with RPL without any changes to RPL.
%RPL do topology maintenance*. 
%//(Collect)//?Chrysso concentrates on data collection while our work tries to improve RPL single channel into multichannel without dealing with the MAC layer. RPL is typically used in ContikiMAC which is a single channel.

In order to maximise the use of multichannel in improving packet delivery, routing topology plays a big role in providing an optimised routing tree on the network that is scalable and energy efficient. There are many studies that were done on routing protocol such as LEACH \cite{leach}, PEGASIS \cite{pegasis}, CTP \cite{ctp} and RPL which is designed largely based on CTP. Recent multichannel protocols such as MiCMAC uses RPL as the routing protocol. Chrysso uses Contiki collect which is a CTP-like data collection protocol in Contiki. We choose to use RPL as it is the standard for IPv6 routing in low power and lossy networks. %RPL forms the network topology dynamically.

%routing in RPL
RPL is a gradient based routing protocol forming any-to-any routing for low power IPv6 networks. RPL topology is a Destination-Oriented Directed Acyclic Graph (DODAG), rooted at LPBR with no cycles. The root has the overall view of the network. The other nodes however, only has knowledge of its neighbours and default router. RPL is a rooted topology which any-to-any traffic is directed towards the root unless the common ancestor is found which the traffic is then routed downwards towards the destination. This strategy is used in order to scale large networks by reducing the routing overhead at the cost of increased hop count through common ancestor. In RPL terminology, the node distance to the root and other nodes is defined as the node's rank. RPL finds the path with the minimum number of transmissions that a node expect to successfully deliver a packet to the destination and switches only if it is less than the current rank to prevent frequent changes~\cite{mrhof}. 

Our proposed protocol takes into account RPL topology formation scheme and the control messages exchange between nodes that take place frequently to maintain the quality of the tree. We enable the RPL control messages to be sent through unicast in order to reduce unnecessary transmitting in broadcast. Our work makes use of RPL topology formation and improves on the channel of the nodes in the topology. Our protocol is a cross layer protocol with a centralised co-ordinator that enables us to make real time decisions without being constraint by the layer capabilities. Our centralised LPBR has the intelligence in choosing the channel for the node as it has the full overview of the network. We also do not blacklist any channel as we do channel checking each time a channel change occur in order to have the update on the channel condition.

%//why ours is better?? compare with MiCMAC, Chrysso, MuChMac. "We are different because because we are cross layer with a centralised co-ordinator. RPL is typically used with ContikiMAC, a single channel protocol"

%We don't blacklist any channels; checks before using the channel. Centralised channel change decision; at LPBR. Nodes decide if the channel recheck LPBR decision of the channel and change. LPBR has the intelligence in choosing the channel for the node as it has the full overview of the condition of all nodes based on a periodic information from the nodes. LPBR will have the information of the good and bad channel for each node. 
%Cross layer; channel changes on network layer while others use layer 2 (?), the MAC layer. This enables us to do cleverly? and deciding the channel cross layer - can do complicated decisions than if with MAC layer channel.